# 多线程
## 多线程基础
任务执行的发展：
- 串行执行
- 基于时间片抢占
- 多进程 + 多线程 模式

多线程程序相较于单线程程序来说，无法预先确定线程调度顺序，也就无法确定哪个方法任务先被处理。
可以为线程设置优先级，可以认为操作系统对高优先级的线程可能调度更频繁，但是我们在编写多线程
程序的时候不能通过线程优先级来保证哪个任务先执行，进而觉得程序的逻辑，这是错误的。

## 创建线程的方法
- 自定义线程类 继承自Thread类
- 任务实现Runnable接口
- 任务实现Callable接口

Java 使用 Thread 来表示一个线程对象，调用其run方法将启动该线程。

## 线程状态
- New
- Runnable
- Block
- Timed Wait
- Terminated


- 正常退出
- 未捕获异常错误退出
- stop()强制退出（不推荐）

.join() 可以等待该线程退出

## 线程中断
- interrupt() (中断异常时需要小心判断如何响应中断信号 以保证线程可以合法退出)
- 中断标志变量 (该变量需要使用volatile修改 保证线程可见效)

当存在线程链的时候，要注意将顶层线程的中断信号传递下去，避免上层的线程中断退出，
但是下层线程还是一直在运行，此时这种线程运行一般是无意义的，只会造成内存和CPU资源的浪费。

## 守护线程
将一个需要在程序运行过程中一直执行的线程设置为守护线程，可以保证在所有工作线程退出，程序
准备结束运行的时候，主线程可以正确退出。
任何非守护线程仍在运行，都将导致主线程无法合法退出。
设置线程为守护线程操作在启动线程之前进行。

## 线程同步
对于在多线程场景下会因为并发修改发生错误的代码块，必须进行线程同步处理，保证在同一时刻
只有一个线程可以进行代码块（临界区）执行代码。一般是加锁，确保同一时刻只有一个线程可以
获取锁。（另一种方法是CAS）

- 注意使用同一个对象作为锁。如果有两个代码块，并且同一时刻只有一个线程可以执行其中的一个代码块
  特别注意两个代码块起始的位置要竞争同一把锁，否则是没有意义的，还是存在并发读写的问题。
- 单条原子操作的语句不需要进行同步处理
    - 原子类型（long/double ...）的赋值
    - 引用类型（list）赋值

## 同步方法
- 对象同步方法锁定的是对象本身
- 类同步方法锁定的是类对象
synchronized 是可重入锁，多个方法锁定同一对象时，当一个线程获取到锁，进入一个方法中执行
时，在这个方法内，如果调用了另一个方法，此时是可以进入的。